pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
  }

  parameters {
    string(
      name: 'IMAGE_REPO',
      defaultValue: 'local',
      description: 'Docker repository namespace (e.g. your Docker Hub username)'
    )
    booleanParam(
      name: 'RUN_SMOKE',
      defaultValue: true,
      description: 'Run the smoke test'
    )
  }

  environment {
    SERVICE_DIR = 'services/flask-api'
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
        script {
          def versionFile = "${env.SERVICE_DIR}/VERSION"
          if (!fileExists(versionFile)) {
            def auto = "0.0.${env.BUILD_NUMBER}"
            writeFile file: versionFile, text: "${auto}\n"
            echo "VERSION was missing. Created temporary version: ${auto}"
          }
          env.APP_VERSION = readFile(versionFile).trim()
          env.GIT_SHORT = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          echo "APP_VERSION=${env.APP_VERSION}, GIT_SHORT=${env.GIT_SHORT}"
        }
        sh 'ls -1 ${SERVICE_DIR} | head -50'
      }
    }

    stage('Python Build & Tests') {
  steps {
    script {
      docker.image('python:3.12-slim').inside('-u root:root') {
        dir(env.SERVICE_DIR) {
          sh '''
            set -eu
            echo "Python path: $(which python)"
            python --version
            export PYTHONPATH=$(pwd):${PYTHONPATH:-}
            export PIP_DISABLE_PIP_VERSION_CHECK=1
            # Optional (keeps things clean and avoids root site-packages pollution)
            python -m venv .venv
            . .venv/bin/activate
            python -m pip install --upgrade pip
            if [ -f requirements.txt ]; then python -m pip install --no-cache-dir -r requirements.txt; fi
            if ls tests/*.py >/dev/null 2>&1; then
              echo "Running pytest..."
              python -m pytest -q
            else
              echo "No tests found."
            fi
          '''
        }
      }
    }
  }
}


stage('Build Image') {
  steps {
    dir(env.SERVICE_DIR) {
      sh '''
        set -eu
        echo "Using IMAGE_REPO='${IMAGE_REPO}' APP_VERSION='${APP_VERSION}'"
        # Pass IMAGE_REPO into make (VERSION read from VERSION file)
        make ci-build IMAGE_REPO="${IMAGE_REPO}"
      '''
    }
  }
}

stage('Smoke Test') {
  when { expression { return params.RUN_SMOKE } }
  steps {
    dir(env.SERVICE_DIR) {
      sh '''
        set -eu
        echo "Smoke test for IMAGE_REPO='${IMAGE_REPO}'"
        make ci-smoke IMAGE_REPO="${IMAGE_REPO}"
      '''
    }
  }
}

    stage('(Optional) Tag Commit Variant') {
  when {
    expression { return env.GIT_SHORT && env.APP_VERSION }   // optional guard
  }
  steps {
    sh '''
      set -eu
      echo "Tagging commit variant..."
      echo "IMAGE_REPO=$IMAGE_REPO"
      echo "APP_VERSION=$APP_VERSION"
      echo "GIT_SHORT=$GIT_SHORT"

      # Safety checks
      [ -n "$IMAGE_REPO" ] || { echo "IMAGE_REPO is empty"; exit 1; }
      [ -n "$APP_VERSION" ] || { echo "APP_VERSION is empty"; exit 1; }
      [ -n "$GIT_SHORT" ] || { echo "GIT_SHORT is empty"; exit 1; }

      # Force repo name lowercase (Docker requirement)
      IMAGE_REPO_LC=$(printf '%s' "$IMAGE_REPO" | tr '[:upper:]' '[:lower:]')

      BASE_TAG="$IMAGE_REPO_LC/flask-api:$APP_VERSION"
      COMMIT_TAG="$IMAGE_REPO_LC/flask-api:$APP_VERSION-$GIT_SHORT"

      echo "Base image tag:   $BASE_TAG"
      echo "Commit image tag: $COMMIT_TAG"

      docker image inspect "$BASE_TAG" >/dev/null 2>&1 || { echo "Image $BASE_TAG not found"; exit 1; }

      docker tag "$BASE_TAG" "$COMMIT_TAG"
      echo "Tagged: $COMMIT_TAG"
    '''
  }
}

stage('Push Image (GHCR)') {
  // This works in both classic and multibranch
  when {
    expression {
      // Determine branch name robustly
      def b1 = env.BRANCH_NAME
      if (b1 == null || b1.trim() == '') {
        // Fallback: ask git directly
        b1 = sh(returnStdout: true, script: 'git rev-parse --abbrev-ref HEAD').trim()
      }
      echo "Evaluated current branch for push condition: '${b1}'"
      return (b1 == 'main')
    }
  }
  environment {
    TARGET_REPO = "${REGISTRY}/${GHCR_USER}/${APP_NAME}"
  }
  steps {
    echo "Preparing to push image to GHCR: ${TARGET_REPO}"
    withCredentials([usernamePassword(credentialsId: 'ghcr-creds',
                                      usernameVariable: 'GHCR_USER_NAME',
                                      passwordVariable: 'GHCR_PAT')]) {
      sh '''
        set -eu

        echo "Logging in to GHCR..."
        echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_USER_NAME" --password-stdin

        echo "Local images before retag:"
        docker images | grep "${LOCAL_REPO}/${APP_NAME}" || true

        echo "Retagging version ${APP_VERSION}..."
        docker tag ${LOCAL_REPO}/${APP_NAME}:${APP_VERSION} ${TARGET_REPO}:${APP_VERSION}

        if docker image inspect ${LOCAL_REPO}/${APP_NAME}:${APP_VERSION}-${GIT_SHORT} > /dev/null 2>&1; then
          echo "Retagging commit variant ${APP_VERSION}-${GIT_SHORT}..."
          docker tag ${LOCAL_REPO}/${APP_NAME}:${APP_VERSION}-${GIT_SHORT} ${TARGET_REPO}:${APP_VERSION}-${GIT_SHORT}
        else
          echo "Commit variant not present; skipping."
        fi

        echo "Tagging 'latest' (lab use)..."
        docker tag ${LOCAL_REPO}/${APP_NAME}:${APP_VERSION} ${TARGET_REPO}:latest

        echo "Pushing tags..."
        docker push ${TARGET_REPO}:${APP_VERSION}
        docker push ${TARGET_REPO}:${APP_VERSION}-${GIT_SHORT} || echo "Commit variant push skipped."
        docker push ${TARGET_REPO}:latest

        echo "DONE pushing to: ${TARGET_REPO}"
      '''
    }
  }
}



  }

  post {
    always {
      echo "Result: ${currentBuild.currentResult}"
      echo "Version: ${env.APP_VERSION ?: 'UNKNOWN'}"
    }
    success { echo 'Pipeline SUCCESS ✅' }
    failure { echo 'Pipeline FAILED ❌' }
  }
}

